scatterplot3d(iris[, 1], iris[, 2], iris[, 3], mar = mar0, color = c("blue",
"black", "red")[iris$Species], pch = 19)
scatterplot3d(iris[, 2], iris[, 3], iris[, 4], mar = mar0, color = c("blue",
"black", "red")[iris$Species], pch = 19)
scatterplot3d(iris[, 3], iris[, 4], iris[, 1], mar = mar0, color = c("blue",
"black", "red")[iris$Species], pch = 19)
scatterplot3d(iris[, 4], iris[, 1], iris[, 2], mar = mar0, color = c("blue",
"black", "red")[iris$Species], pch = 19)
detach(package:scatterplot3d)
iris.lda <- lda(Species~.,data=iris)
iris.lda
iris.pred <- predict(iris.lda)
#A Stacked Histogram of the LDA Values
ldahist(data = iris.pred$x[,1], g=iris$Species)
# Confusion matrix
table(iris$Species,iris.pred$class)
#rm(list = ls())
# load required packages
library(psych)
library(MASS)
library(ICSNP)
library(ggplot2)
library(ggcorrplot)
library(devtools)
library(ggbiplot)
library(rrcov)
x1<-diabetes_part[1:384,]
x2<-salmon[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
plot(diabetes_part)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4),cex=1)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
plot(diabetes_part)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4),cex=1)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
plot(diabetes_part, pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50),main="")
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4),cex=1)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
par(mar=c(4,4,2,1))
data(salmon)
plot(salmon$Freshwater,salmon$Marine,xlab="Freshwater",ylab="Marine",
pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50),main="")
legend("topright",legend=c("Alaskan","Canadian"),pch=c(18,20),col=c(2,4),cex=1)
plot(diabetes_part$BloodPressure, diabetes_part$Glucose, xlab="BloodPressure",ylab="Glucose", pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50),main="")
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4),cex=1)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
plot(diabetes_part$BloodPressure, diabetes_part$Glucose, xlab="BloodPressure",ylab="Glucose", pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50),main="")
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4),cex=1)
x1<-diabetes_part[1:384,]
x2<-diabetes_part[385:768,]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-383*(var(x1)+var(x2))/766
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(diabetes_part[,2],-(w[1]*diabetes_part[,2]+w0)/w[2])
par(mar=c(4,4,2,1))
data(salmon)
plot(salmon$Freshwater,salmon$Marine,xlab="Freshwater",ylab="Marine",
pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50),main="")
legend("topright",legend=c("Alaskan","Canadian"),pch=c(18,20),col=c(2,4),cex=1)
x1<-salmon[1:50,2:3]
x2<-salmon[51:100,2:3]
# compute sample mean vectors:
x1.mean<-colMeans(x1)
x2.mean<-colMeans(x2)
# compute pooled estimate for the covariance matrix:
S.u<-49*(var(x1)+var(x2))/98
w<-solve(S.u)%*%(x1.mean-x2.mean)
w0<--(x1.mean+x2.mean)%*%w/2
lines(salmon[,2],-(w[1]*salmon[,2]+w0)/w[2])
lda.obj<-lda(Origin~Freshwater+Marine,data=salmon,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=salmon)
#determine how well the model fits
table(salmon[,4],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(salmon[,2:3],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Alaskan","Canadian"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_data = diabetes_data[,-10]
lda.obj<-lda(Outcome~Glucose+BloodPressure,data=diabetes_data,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_data)
#determine how well the model fits
table(salmon[,9],plda$class)
#Use function LDA in MASS package:
diabetes_data = diabetes_data[,-10]
lda.obj<-lda(Outcome~Glucose+BloodPressure,data=diabetes_data,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_data)
#determine how well the model fits
table(diabetes_data[,9],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_data[,2:3],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
View(diabetes_data)
#Use function LDA in MASS package:
diabetes_data = diabetes_data[,-10]
lda.obj<-lda(Outcome~Pregnancies+Age,data=diabetes_data,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_data)
#determine how well the model fits
table(diabetes_data[,9],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_data[,2:3],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[1:100,-1:-5]
lda.obj<-lda(Outcome~Pregnancies+Age,data=diabetes_lda,prior=c(1,1)/2)
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[1:100,-1:-6]
lda.obj<-lda(Outcome~Pregnancies+Age,data=diabetes_lda,prior=c(1,1)/2)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~Pregnancies+Age,data=diabetes_lda,prior=c(1,1)/2)
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,9],plda$class)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1]
diabetes_lda = diabetes_data[,-3:-7]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
View(diabetes_lda)
View(diabetes_data)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1]
diabetes_lda = diabetes_data[,-2:-8]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-0]
diabetes_lda = diabetes_data[,-2:-8]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
View(diabetes_lda)
diabetes_lda = diabetes_data[,-0]
View(diabetes_lda)
diabetes_lda = diabetes_data[,-1]
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-0]
diabetes_lda = diabetes_lda[,-3:-7]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
View(diabetes_lda)
diabetes_lda = diabetes_data[,-1]
diabetes_lda = diabetes_lda[,-3:-7]
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-0]
diabetes_lda = diabetes_lda[,-3:-7]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~Glucose+BloodPressure,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
diabetes_lda = diabetes_data[,-1]
diabetes_lda = diabetes_lda[,-3:-7]
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-0]
diabetes_lda = diabetes_lda[,-3:-7]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~Glucose+BloodPressure,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1]
diabetes_lda = diabetes_lda[,-3:-7]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~Glucose+BloodPressure,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
lda.obj<-lda(Origin~Freshwater+Marine,data=salmon,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=salmon)
#determine how well the model fits
table(salmon[,4],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(salmon[,2:3],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Alaskan","Canadian"),pch=c(18,20),col=c(2,4))
View(diabetes_lda)
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-5]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(2,2)/2)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
View(diabetes_lda)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
diabetes_lda = scale(diabetes_lda)
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
diabetes_lda = scale(as.matrix(diabetes_lda))
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
diabetes_lda["pred"]=(slope*diabetes_lda$DiabetesPedigreeFunction+intercept)>diabetes_lda$Age
diabetes_lda["pred"]=(slope*diabetes_lda$DiabetesPedigreeFunction+intercept)>diabetes_lda$Age
View(diabetes_lda)
diabetes_lda["pred"]=as.numeric((slope*diabetes_lda$DiabetesPedigreeFunction+intercept)>diabetes_lda$Age)
diabetes_lda["Outcome"==0]
diabetes_lda
diabetes_lda["Outcome"==0]
diabetes_lda[diabetes_lda$Outcome==0]
which(diabetes_lda$Outcome==0)
which(diabetes_lda[which(diabetes_lda$Outcome==0)]$pred==0)
diabetes_lda[which(diabetes_lda$Outcome==0)]
diabetes_lda[which(diabetes_lda$Outcome==0),]
diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0
which(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)
length(which(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0))
length(which(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0))/(100-sum(diabetes_lda$Outcome))
(100-sum(diabetes_lda$Outcome))
length(which(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0))
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
diabetes_lda["pred"]=as.numeric((slope*diabetes_lda$DiabetesPedigreeFunction+intercept)>diabetes_lda$Age)
length(which(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0))/(100-sum(diabetes_lda$Outcome))
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)/(100-sum(diabetes_lda$Outcome))
diabetes_lda["pred"]=as.numeric((slope*diabetes_lda$DiabetesPedigreeFunction+intercept)<diabetes_lda$Age)
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)/(100-sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==1)
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==0)
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==1)
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==0)/(sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==1)/(sum(diabetes_lda$Outcome))
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
diabetes_lda["pred"]=as.numeric((slope*diabetes_lda$DiabetesPedigreeFunction+intercept)<diabetes_lda$Age)
# construct confusion matrix
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)/(100-sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==1)/(100-sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==0)/(sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==1)/(sum(diabetes_lda$Outcome))
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
#Use function LDA in MASS package:
diabetes_lda = diabetes_data[,-1:-6]
diabetes_lda = diabetes_lda[1:100,]
lda.obj<-lda(Outcome~DiabetesPedigreeFunction+Age,data=diabetes_lda,prior=c(1,1)/2)
plda<-predict(object=lda.obj,newdata=diabetes_lda)
#determine how well the model fits
table(diabetes_lda[,3],plda$class)
#plot the decision line
gmean <- lda.obj$prior %*% lda.obj$means
const <- as.numeric(gmean %*%lda.obj$scaling)
slope <- - lda.obj$scaling[1] / lda.obj$scaling[2]
intercept <- const / lda.obj$scaling[2]
diabetes_lda["pred"]=as.numeric((slope*diabetes_lda$DiabetesPedigreeFunction+intercept)<diabetes_lda$Age)
# construct confusion matrix
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==0)/(100-sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==0),"pred"]==1)/(100-sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==0)/(sum(diabetes_lda$Outcome))
sum(diabetes_lda[which(diabetes_lda$Outcome==1),"pred"]==1)/(sum(diabetes_lda$Outcome))
#Plot decision boundary
plot(diabetes_lda[,1:2],pch=rep(c(18,20),each=50),col=rep(c(2,4),each=50))
abline(intercept, slope)
legend("topright",legend=c("Class 0","Class 1"),pch=c(18,20),col=c(2,4))
View(diabetes_data)
source('~/Box/STA_243/Comp_Stats/Project-3/CS_RS_code_hw3.R')
############ Problem 1 ############
library(readmnist)
# data loading for training / test set images
train_file = file("train-images-idx3-ubyte", "rb")
############ Problem 1 ############
library(readmnist)
# set working directory
setwd("./")  # set path to the current directory
# data loading for training / test set images
train_file = file("train-images-idx3-ubyte", "rb")
############ Problem 1 ############
library(readmnist)
# set working directory
setwd("/Users/furinkazan/Box/STA_243/Comp_Stats/Project-3")  # set path to the current directory
# data loading for training / test set images
train_file = file("train-images-idx3-ubyte", "rb")
source('~/Box/STA_243/Comp_Stats/Project-3/CS_RS_code_hw3.R')
graphics.off()
source('~/Box/STA_243/Comp_Stats/Project-3/CS_RS_code_hw3.R')
graphics.off()
rm(list=ls())
source('~/Box/STA_243/Comp_Stats/Project-3/CS_RS_code_hw3.R')
graphics.off()
rm(list=ls())
source('~/Box/STA_243/Comp_Stats/Project-3/CS_RS_code_hw3.R')
graphics.off()
rm(list=ls())
