SHDy = SHDXy_list[[2]]  # unpack
time_sket_list[[i]] = system.time(perform_LS(SHDX, SHDy))
return (time_sket_list)
}
time_sket_list
# Part (c)
# Compare the calculation time for the full least squares problem and the sketched OLS.
# Note: first calculate Xâˆ— = Î¦X and yâˆ— = Î¦y, and apply system.time() function on (XTâˆ— Xâˆ—)^(-1) XTâˆ— yâˆ—
# and compare to the calculation time of (XT X)^(-1) XT y
# Repeat these steps for  = .1, .05, .01, .001 and present your results in a table
epsi_vector = c(0.1, 0.05, 0.01, 0.001)
time_sket_list = c()  # make an empty vector
# test_S_list = main_SketchedOLS(design_X, respon_Y, 0.1)
perform_LS = function(X, y) {
beta_s = solve(t(X) %*% X) %*% (t(X) %*% y)
return (beta_s)
}
# Time for OLS
t_ols = system.time(perform_LS(design_X, as.matrix(respon_Y)))
# Time for Sketched OLS with 4 different epsilons
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket_list = c(time_sket_list, system.time(perform_LS(SHDX, SHDy)))
return (time_sket_list)
}
time_sket_list
# main function: Sketched-OLS
main_SketchedOLS = function (X, y, epsi) {
# Param:
# X: design matrix (nxd)
# y: response y (n)
# epsi: error parameter
# Return:
# beta:
dim_n = dim(X)[1]
dim_d = dim(X)[2]
r = helper_r(dim_d, dim_n, epsi)  # instance of r
D_list = helper_diagD(X, y, dim_n)
DX = D_list[[1]]  # instance D*X
Dy = D_list[[2]]  # instance D*y
HDX = apply(DX, 2, fhm)
HDy = fhm(Dy)
S_list = helper_sampleS(HDX, HDy, dim_n, r)
#SHDX = S_list[1]  # no need to unpack
#SHDy = S_list[2]  # no need to unpack
return (S_list)
}
# Time for Sketched OLS with 4 different epsilons
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket_list = c(time_sket_list, system.time(perform_LS(SHDX, SHDy)))
return (time_sket_list)
}
time_sket_list
# Part (c)
# Compare the calculation time for the full least squares problem and the sketched OLS.
# Note: first calculate Xâˆ— = Î¦X and yâˆ— = Î¦y, and apply system.time() function on (XTâˆ— Xâˆ—)^(-1) XTâˆ— yâˆ—
# and compare to the calculation time of (XT X)^(-1) XT y
# Repeat these steps for  = .1, .05, .01, .001 and present your results in a table
epsi_vector = c(0.1, 0.05, 0.01, 0.001)
# test_S_list = main_SketchedOLS(design_X, respon_Y, 0.1)
perform_LS = function(X, y) {
beta_s = solve(t(X) %*% X) %*% (t(X) %*% y)
return (beta_s)
}
# Time for OLS
t_ols = system.time(perform_LS(design_X, as.matrix(respon_Y)))
t_ols
# Time for Sketched OLS with 4 different epsilons
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket = system.time(perform_LS(SHDX, SHDy))
print(time_sket)
}
t_ols[[1]]
View(helper_sampleS)
# Here defines some helper functions for the main Sketched-OLS function
helper_r = function(dim_d, dim_n, epsi) {
# helper function 6.1: initialize r
# Param:
# dim_d: number of column of matrix
# dim_n: number of rows of matrix
# epsi: error parameter
# Return:
# r: an integer as upper trails
r = as.integer(dim_d * log(dim_n) / epsi)
return (r)
}
0.623+0.128+0.843
# Time for OLS
t_ols = system.time(perform_LS(design_X, as.matrix(respon_Y)))
t_ols
t_ols[[1]]
t_ols[[2]]
t_ols[[3]]
# In the following, considering the randomness of time measurements, we performed the calculation for 200
# time to get stable conclusions
# Time measurements list
usr_time_vec = c()
sys_time_vec = c()
elapsed_time_vec = c()
# Time for OLS
for (i in 1:50) {
t_ols = system.time(perform_LS(design_X, as.matrix(respon_Y)))
usr_time_vec = c(usr_time_vec, t_ols[[1]])
sys_time_vec = c(sys_time_vec, t_ols[[2]])
elapsed_time_vec = c(elapsed_time_vec, t_ols[[3]])
}
usr_time_vec
mean(usr_time_vec)
# printout
print(paste("Average user time for OLS = ", mean(usr_time_vec)))
print(paste("Average system time for OLS = ", mean(sys_time_vec)))
print(paste("Average elapsed time for OLS = ", mean(elapsed_time_vec)))
# Time for Sketched OLS with 4 different epsilons
for (t in 1:5) {
usr_time_vec = c()
sys_time_vec = c()
elapsed_time_vec = c()
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket = system.time(perform_LS(SHDX, SHDy))
print(time_sket)
}
}
usr_time_vec_epsi_0.1
usr_time_vec_epsi1 = c()  # 0.1
sys_time_vec_epsi1 = c()
elapsed_time_vec_epsi1 = c()
usr_time_vec_epsi2 = c()  # 0.05
sys_time_vec_epsi2 = c()
elapsed_time_vec_epsi2 = c()
usr_time_vec_epsi3 = c()  # 0.01
sys_time_vec_epsi3 = c()
elapsed_time_vec_epsi3 = c()
usr_time_vec_epsi4 = c()  # 0.001
sys_time_vec_epsi4 = c()
elapsed_time_vec_epsi4 = c()
# Time for Sketched OLS with 4 different epsilons
for (t in 1:5) {
# loops through 4 different epsilons
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket = system.time(perform_LS(SHDX, SHDy))
if (i == 1) {
usr_time_vec_epsi1 = c(usr_time_vec_epsi1, time_sket[[1]])
sys_time_vec_epsi1 = c(sys_time_vec_epsi1, time_sket[[2]])
elapsed_time_vec_epsi1 = c(elapsed_time_vec_epsi1, time_sket[[3]])
}
else if (i == 2) {
usr_time_vec_epsi2 = c(usr_time_vec_epsi2, time_sket[[1]])
sys_time_vec_epsi2 = c(sys_time_vec_epsi2, time_sket[[2]])
elapsed_time_vec_epsi2 = c(elapsed_time_vec_epsi2, time_sket[[3]])
}
else if (i == 3) {
usr_time_vec_epsi3 = c(usr_time_vec_epsi3, time_sket[[1]])
sys_time_vec_epsi3 = c(sys_time_vec_epsi3, time_sket[[2]])
elapsed_time_vec_epsi3 = c(elapsed_time_vec_epsi3, time_sket[[3]])
}
else if (i == 4) {
usr_time_vec_epsi4 = c(usr_time_vec_epsi4, time_sket[[1]])
sys_time_vec_epsi4 = c(sys_time_vec_epsi4, time_sket[[2]])
elapsed_time_vec_epsi4 = c(elapsed_time_vec_epsi4, time_sket[[3]])
}
}
}
# printout average Sketched OLS time stats with 4 different epsilons
print(paste("Average user time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average system time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average user time for Sketched OLS with epsi = 0.05: ", mean(usr_time_vec_epsi2)))
print(paste("Average system time for Sketched OLS with epsi = 0.05: ", mean(usr_time_vec_epsi2)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.05: ", mean(usr_time_vec_epsi2)))
print(paste("Average user time for Sketched OLS with epsi = 0.01: ", mean(usr_time_vec_epsi3)))
print(paste("Average system time for Sketched OLS with epsi = 0.01: ", mean(usr_time_vec_epsi3)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.01: ", mean(usr_time_vec_epsi3)))
print(paste("Average user time for Sketched OLS with epsi = 0.001: ", mean(usr_time_vec_epsi4)))
print(paste("Average system time for Sketched OLS with epsi = 0.001: ", mean(usr_time_vec_epsi4)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.001: ", mean(usr_time_vec_epsi4)))
usr_time_vec_epsi1 = c()  # 0.1
sys_time_vec_epsi1 = c()
elapsed_time_vec_epsi1 = c()
usr_time_vec_epsi2 = c()  # 0.05
sys_time_vec_epsi2 = c()
elapsed_time_vec_epsi2 = c()
usr_time_vec_epsi3 = c()  # 0.01
sys_time_vec_epsi3 = c()
elapsed_time_vec_epsi3 = c()
usr_time_vec_epsi4 = c()  # 0.001
sys_time_vec_epsi4 = c()
elapsed_time_vec_epsi4 = c()
# Time for Sketched OLS with 4 different epsilons
for (t in 1:5) {
# loops through 4 different epsilons
for (i in 1:4) {
SHDXy_list = main_SketchedOLS(design_X, respon_Y, epsi_vector[i])
SHDX = SHDXy_list[[1]]  # unpack
SHDy = SHDXy_list[[2]]  # unpack
time_sket = system.time(perform_LS(SHDX, SHDy))
if (i == 1) {
usr_time_vec_epsi1 = c(usr_time_vec_epsi1, time_sket[[1]])
sys_time_vec_epsi1 = c(sys_time_vec_epsi1, time_sket[[2]])
elapsed_time_vec_epsi1 = c(elapsed_time_vec_epsi1, time_sket[[3]])
}
else if (i == 2) {
usr_time_vec_epsi2 = c(usr_time_vec_epsi2, time_sket[[1]])
sys_time_vec_epsi2 = c(sys_time_vec_epsi2, time_sket[[2]])
elapsed_time_vec_epsi2 = c(elapsed_time_vec_epsi2, time_sket[[3]])
}
else if (i == 3) {
usr_time_vec_epsi3 = c(usr_time_vec_epsi3, time_sket[[1]])
sys_time_vec_epsi3 = c(sys_time_vec_epsi3, time_sket[[2]])
elapsed_time_vec_epsi3 = c(elapsed_time_vec_epsi3, time_sket[[3]])
}
else if (i == 4) {
usr_time_vec_epsi4 = c(usr_time_vec_epsi4, time_sket[[1]])
sys_time_vec_epsi4 = c(sys_time_vec_epsi4, time_sket[[2]])
elapsed_time_vec_epsi4 = c(elapsed_time_vec_epsi4, time_sket[[3]])
}
}
}
# printout average Sketched OLS time stats with 4 different epsilons
print(paste("Average user time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average system time for Sketched OLS with epsi = 0.1: ", mean(sys_time_vec_epsi1)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.1: ", mean(elapsed_time_vec_epsi1)))
print(paste("Average user time for Sketched OLS with epsi = 0.05: ", mean(usr_time_vec_epsi2)))
print(paste("Average system time for Sketched OLS with epsi = 0.05: ", mean(sys_time_vec_epsi2)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.05: ", mean(elapsed_time_vec_epsi2)))
print(paste("Average user time for Sketched OLS with epsi = 0.01: ", mean(usr_time_vec_epsi3)))
print(paste("Average system time for Sketched OLS with epsi = 0.01: ", mean(sys_time_vec_epsi3)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.01: ", mean(elapsed_time_vec_epsi3)))
print(paste("Average user time for Sketched OLS with epsi = 0.001: ", mean(usr_time_vec_epsi4)))
print(paste("Average system time for Sketched OLS with epsi = 0.001: ", mean(sys_time_vec_epsi4)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.001: ", mean(elapsed_time_vec_epsi4)))
usr_time_vec_epsi1
elapsed_time_vec_epsi4
sys_time_vec_epsi3
usr_time_vec_epsi1 = c()  # 0.1
sys_time_vec_epsi1 = c()
elapsed_time_vec_epsi1 = c()
usr_time_vec_epsi2 = c()  # 0.05
sys_time_vec_epsi2 = c()
elapsed_time_vec_epsi2 = c()
usr_time_vec_epsi3 = c()  # 0.01
sys_time_vec_epsi3 = c()
elapsed_time_vec_epsi3 = c()
usr_time_vec_epsi4 = c()  # 0.001
sys_time_vec_epsi4 = c()
elapsed_time_vec_epsi4 = c()
elapsed_time_vec_epsi4
for (i in 1:50) {
SHDXy_list1 = main_SketchedOLS(design_X, respon_Y, epsi_vector[1])
SHDX1 = SHDXy_list1[[1]]  # unpack
SHDy1 = SHDXy_list1[[2]]  # unpack
time_sket1 = system.time(perform_LS(SHDX1, SHDy1))
usr_time_vec_epsi1 = c(usr_time_vec_epsi1, time_sket1[[1]])
sys_time_vec_epsi1 = c(sys_time_vec_epsi1, time_sket1[[2]])
elapsed_time_vec_epsi1 = c(elapsed_time_vec_epsi1, time_sket1[[3]])
}
print(paste("Average user time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average system time for Sketched OLS with epsi = 0.1: ", mean(sys_time_vec_epsi1)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.1: ", mean(elapsed_time_vec_epsi1)))
epsi_vector[1]
usr_time_vec_epsi1
library("phangorn")
# Part (a)
# Implement the Sketched-OLS algorithm: following P5 of SketchingLS.pdf, Algorithm 1 The Sketched-OLS algorithm
# Here defines some helper functions for the main Sketched-OLS function
helper_r = function(dim_d, dim_n, epsi) {
# helper function 6.1: initialize r
# Param:
# dim_d: number of column of matrix
# dim_n: number of rows of matrix
# epsi: error parameter
# Return:
# r: an integer as upper trails
r = as.integer(dim_d * log(dim_n) / epsi)
return (r)
}
helper_sampleS = function(HDX, HDy, dim_n, r) {
# helper function 6.2: generate sub-sampling matrix
# Param:
# HDX: matrix multiplication result of HDX
# HDy: matrix multiplication result of HDy
# dim_n: number of rows of matrix
# r: an integer as upper trails
# Return:
# list(sampleX, sampley): list of matrix multiplication result of SHDX and SHDy
flag = sqrt(dim_n / r)
sampleS = sample(1:dim_n, size=r, replace=T)
sampleX = flag*HDX[sampleS, ]
sampley = flag*HDy[sampleS]
return (list(sampleX, sampley))
}
helper_diagD = function(X, y, dim_n) {
# helper function 6.3: generate D âˆˆ RnÃ—n be a diagonal matrix
# Param:
# X: the design matrix
# y: the response vector
# dim_n: number of rows of matrix
# Return:
# list(DX, Dy): list of matrix multiplication result of DX and Dy
selectDii = sample(c(1,-1), size=dim_n, replace=T, prob=c(1/2, 1/2))
DX = apply(X, 2, function(i) selectDii*i)
Dy = selectDii * y
return(list(DX, Dy))
}
# main function: Sketched-OLS
main_SketchedOLS = function (X, y, epsi) {
# Param:
# X: design matrix (nxd)
# y: response y (n)
# epsi: error parameter
# Return:
# S_list: list of matrix multiplication result of SHDX and SHDy
dim_n = dim(X)[1]
dim_d = dim(X)[2]
r = helper_r(dim_d, dim_n, epsi)  # instance of r
D_list = helper_diagD(X, y, dim_n)
DX = D_list[[1]]  # instance D*X
Dy = D_list[[2]]  # instance D*y
HDX = apply(DX, 2, fhm)
HDy = fhm(Dy)
S_list = helper_sampleS(HDX, HDy, dim_n, r)
#SHDX = S_list[1]  # no need to unpack
#SHDy = S_list[2]  # no need to unpack
return (S_list)
}
# Part (b)
# Generate design matrix X and response y with elements drawn iid from a Uniform(0, 1) distribution
design_X = matrix(nrow=1048576, ncol=20)
for (i in 1:20) {
design_X[, i] = runif(1048576, 0, 1)
}
# generate design matrix X
respon_Y = as.matrix(runif(1048576, 0, 1))  # generate response Y
# stepwise tests on Part (a):
# test_n = dim(design_X)[1]
# test_d = dim(design_X)[2]
# test_r = helper_r(test_d, test_n, 0.1)
# test_d_list = helper_diagD(design_X, respon_Y, test_n)
# test_DX = test_d_list[[1]]
# test_Dy = test_d_list[[2]]
# test_HDX = apply(test_DX, 2, fhm)
# test_HDy = fhm(test_Dy)
# test_s_list = helper_sampleS(test_HDX, test_HDy, test_n, test_r)
# test_S_list = main_SketchedOLS(design_X, respon_Y, 0.1)
# All tests passed!
# Part (c)
# Compare the calculation time for the full least squares problem and the sketched OLS.
# Note: first calculate Xâˆ— = Î¦X and yâˆ— = Î¦y, and apply system.time() function on (XTâˆ— Xâˆ—)^(-1) XTâˆ— yâˆ—
# and compare to the calculation time of (XT X)^(-1) XT y
# Repeat these steps for  = .1, .05, .01, .001 and present your results in a table
epsi_vector = c(0.1, 0.05, 0.01, 0.001)
perform_LS = function(X, y) {
# perform OLS
beta_s = solve(t(X) %*% X) %*% (t(X) %*% y)
return (beta_s)
}
# In the following, considering the randomness of time measurements, we performed the calculation for 200
# time to get stable conclusions
# Time measurements list
usr_time_vec = c()
sys_time_vec = c()
elapsed_time_vec = c()
# Time for OLS
for (i in 1:200) {
t_ols = system.time(perform_LS(design_X, as.matrix(respon_Y)))
usr_time_vec = c(usr_time_vec, t_ols[[1]])
sys_time_vec = c(sys_time_vec, t_ols[[2]])
elapsed_time_vec = c(elapsed_time_vec, t_ols[[3]])
}
# printout average OLS time stats
print(paste("Average user time for OLS = ", mean(usr_time_vec)))
print(paste("Average system time for OLS = ", mean(sys_time_vec)))
print(paste("Average elapsed time for OLS = ", mean(elapsed_time_vec)))
# For Sketched OLS:
# initialize time measurements vectors
usr_time_vec_epsi1 = c()  # 0.1
sys_time_vec_epsi1 = c()
elapsed_time_vec_epsi1 = c()
usr_time_vec_epsi2 = c()  # 0.05
sys_time_vec_epsi2 = c()
elapsed_time_vec_epsi2 = c()
usr_time_vec_epsi3 = c()  # 0.01
sys_time_vec_epsi3 = c()
elapsed_time_vec_epsi3 = c()
usr_time_vec_epsi4 = c()  # 0.001
sys_time_vec_epsi4 = c()
elapsed_time_vec_epsi4 = c()
# Time for Sketched OLS with epsilons = 0.1
for (i in 1:200) {
SHDXy_list1 = main_SketchedOLS(design_X, respon_Y, epsi_vector[1])
SHDX1 = SHDXy_list1[[1]]  # unpack
SHDy1 = SHDXy_list1[[2]]  # unpack
time_sket1 = system.time(perform_LS(SHDX1, SHDy1))
usr_time_vec_epsi1 = c(usr_time_vec_epsi1, time_sket1[[1]])
sys_time_vec_epsi1 = c(sys_time_vec_epsi1, time_sket1[[2]])
elapsed_time_vec_epsi1 = c(elapsed_time_vec_epsi1, time_sket1[[3]])
}
# time stats
print(paste("Average user time for Sketched OLS with epsi = 0.1: ", mean(usr_time_vec_epsi1)))
print(paste("Average system time for Sketched OLS with epsi = 0.1: ", mean(sys_time_vec_epsi1)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.1: ", mean(elapsed_time_vec_epsi1)))
# Time for Sketched OLS with epsilons = 0.05
for (i in 1:200) {
SHDXy_list2 = main_SketchedOLS(design_X, respon_Y, epsi_vector[2])
SHDX2 = SHDXy_list2[[1]]  # unpack
SHDy2 = SHDXy_list2[[2]]  # unpack
time_sket2 = system.time(perform_LS(SHDX2, SHDy2))
usr_time_vec_epsi2 = c(usr_time_vec_epsi2, time_sket2[[1]])
sys_time_vec_epsi2 = c(sys_time_vec_epsi2, time_sket2[[2]])
elapsed_time_vec_epsi2 = c(elapsed_time_vec_epsi2, time_sket2[[3]])
}
# time stats
print(paste("Average user time for Sketched OLS with epsi = 0.05: ", mean(usr_time_vec_epsi2)))
print(paste("Average system time for Sketched OLS with epsi = 0.05: ", mean(sys_time_vec_epsi2)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.05: ", mean(elapsed_time_vec_epsi2)))
# Time for Sketched OLS with epsilons = 0.01
for (i in 1:200) {
SHDXy_list3 = main_SketchedOLS(design_X, respon_Y, epsi_vector[3])
SHDX3 = SHDXy_list3[[1]]  # unpack
SHDy3 = SHDXy_list3[[2]]  # unpack
time_sket3 = system.time(perform_LS(SHDX3, SHDy3))
usr_time_vec_epsi3 = c(usr_time_vec_epsi3, time_sket3[[1]])
sys_time_vec_epsi3 = c(sys_time_vec_epsi3, time_sket3[[2]])
elapsed_time_vec_epsi3 = c(elapsed_time_vec_epsi3, time_sket3[[3]])
}
# time stats
print(paste("Average user time for Sketched OLS with epsi = 0.01: ", mean(usr_time_vec_epsi3)))
print(paste("Average system time for Sketched OLS with epsi = 0.01: ", mean(sys_time_vec_epsi3)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.01: ", mean(elapsed_time_vec_epsi3)))
# Time for Sketched OLS with epsilons = 0.001
for (i in 1:200) {
SHDXy_list4 = main_SketchedOLS(design_X, respon_Y, epsi_vector[4])
SHDX4 = SHDXy_list4[[1]]  # unpack
SHDy4 = SHDXy_list4[[2]]  # unpack
time_sket4 = system.time(perform_LS(SHDX4, SHDy4))
usr_time_vec_epsi4 = c(usr_time_vec_epsi4, time_sket4[[1]])
sys_time_vec_epsi4 = c(sys_time_vec_epsi4, time_sket4[[2]])
elapsed_time_vec_epsi4 = c(elapsed_time_vec_epsi4, time_sket4[[3]])
}
# time stats
print(paste("Average user time for Sketched OLS with epsi = 0.001: ", mean(usr_time_vec_epsi4)))
print(paste("Average system time for Sketched OLS with epsi = 0.001: ", mean(sys_time_vec_epsi4)))
print(paste("Average elapsed time for Sketched OLS with epsi = 0.001: ", mean(elapsed_time_vec_epsi4)))
matC = matA %*% matB  # exact matmul
matM_list = list(matM_r20, matM_r50, matM_r100, matM_r200)  # list contains list of matrix M
r_vec = c(20, 50, 100, 200)
# loop through r's
error_MC_list = c()  # initialize error list
for (i in 1:length(matM_list)){
# calculate the relative approximation error
diff = as.matrix(matM_list[[i]]) - matC
error_MC = norm(diff, type="F") / (norm(matA, type="F") * norm(matB, type="F"))
error_MC_list = c(error_MC_list, error_MC)
}
# show as a table
table_error = data.frame("Sample size r" = r_vec, "Errors" = error_MC_list)
print(table_error)
power_iteration = function(A, v0, eps = 1e-6, maxiter=100) {
# Algorithm 3 Power Method
# Param:
# A: matrix to be took in
# v0: initial vector, denoted as c0 in the notes
# Return:
# v_final: output of approximate eigenvector
c_in = v0
iter = 0
for (i in 1:maxiter) {
c_out = A %*% c_in  # calculate new c
c_out = c_out / sqrt(sum(c_out^2))  # with normalization
error_eigen = 1 - sum(c_in * c_out)^2 # sum((sapply(c_out, abs) - sapply(c_in, abs))^2)
if (error_eigen < eps) {
print("Algorithm finished")
break
} else if (iter == maxiter) {
print("Algorithm unfinished and stopped with the default max iterations")
print(paste("Current error = ", error_eigen))
} else {
c_in = c_out
iter = iter + 1
}
}
v_final = c_out
return(v_final)
}
# testing part (provided)
set.seed(5)
E = matrix(rnorm(100), 10, 10)
v = c(1, rep(0, 9))
lams = 1:10
prods = c()
for (lambda in lams) {
X = lambda*outer(v, v) + E  # 10x10
v0 = rep(1, nrow(E))
v0 = v0/sqrt(sum(v0^2))
vv = power_iteration(X, v0)
prods = c(prods, abs(v %*% vv))
}
par(mfrow=c(1,1))  # reset figure size
plot(lams, prods, "b")
